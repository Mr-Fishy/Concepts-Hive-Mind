---
tags: spaces://#sebesta/chapter-1
---
| Keyword                      | Definition / Use                                                                                                                                                                                                                                                                                                                                                                   |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Imperative**               | **Focuses on how the computation is done** by explicitly managing the program's state (memory). A program is a sequence of commands that specify step-by-step how to change the contents of memory locations. The central feature is the **assignment statement**. Most common languages are imperative. **Examples:** C, C++, C#, Java, Python (supports imperative style).       |
| **Von Neumann Architecture** | The underlying design of most non-parallel computers. It consists of a CPU and a single, central memory. Data and instructions are stored in memory and are fetched to the CPU. The **Imperative paradigm is heavily influenced by this architecture** because the assignment statement is conceptually modeled after the fetching and storing of data between the CPU and memory. |
| **Functional**               | **Focuses on what the computation is** by treating computation as the evaluation of mathematical functions, avoiding state and mutable data. **Examples:** LISP, Scheme, Haskell.                                                                                                                                                                                                  |
| **Logic**                    | **Focuses on what the result is expected** by defining a set of facts and rules and asking the system to infer the answer. **Example:** Prolog.                                                                                                                                                                                                                                    |
| **Object-Oriented (OO)**     | A further abstraction of the imperative approach. Data and code are encapsulated into **objects**, and changes to the state are managed through methods. **Examples:** Java, C++, Ruby, Smalltalk.                                                                                                                                                                                 |

| Factor            | Detail / Concept                                                                                                                                                                                                                                                                                                                      |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Simplicity**    | A language should have a manageable number of basic constructs. **Feature multiplicity** (having multiple ways to accomplish the same operation, like `x = x + 1`, `x++`, `x += 1` in C) reduces readability.                                                                                                                         |
| **Orthogonality** | The principle that a relatively small set of primitive constructs can be combined in a relatively small number of ways to build control and data structures. Every possible combination is valid and meaningful. **Lack of Orthogonality** (e.g., in C) leads to exceptions and special rules, which are harder to remember and read. |
| **Data Types**    | The existence of adequate predefined types (e.g., `boolean`, `float`) and the ability to define new data types (e.g., **classes** or **records**) clearly enhances the meaning and readability of the code.                                                                                                                           |
| **Syntax Design** | **Identifiers:** Should be unrestricted in length for meaningful names. **Special Words:** Use keywords logically (e.g., using `end if` vs. simply ending with a semicolon).                                                                                                                                                          |

| Conflict                                                                 | Description                                                                                                                                                                                                                                                                                                                   |
| ------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Writability vs. Reliability (The C/C++ Trade-off)**                    | Features like **pointers** and **implicit type conversion** (high writability for low-level tasks) allow the programmer maximum control. However, this power makes it easy to introduce errors (e.g., dangling pointers, buffer overflows), drastically lowering reliability.                                                 |
| **Readability vs. Writability (The Simplicity Trade-off)**               | Some constructs, like complex arithmetic shortcuts or overloaded operators, may allow code to be written very **concisely** (high writability) but make it extremely difficult for another programmer to quickly grasp the operation (low readability).                                                                       |
| **Cost of Execution vs. Reliability (The Dynamic vs. Static Trade-off)** | **Dynamic type checking** (checking types during program execution) increases runtime reliability by catching errors the compiler missed, but it adds an **overhead** to every operation, increasing the cost of execution. **Static type checking** (checking types at compile time) is faster at runtime but less flexible. |

| Keyword                            | Method & Mechanism                                                                                                                                                                                                                                                                                                                                   |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Pure Interpretation**            | The interpreter program acts as a **software simulation of a machine** that understands the source code. It reads one line of source code, executes the corresponding machine operations, and moves to the next. **Advantages:** Immediate execution, excellent for debugging. **Disadvantages:** **Slow** (10â€“100 times slower than compiled code). |
| **Compilation**                    | The compiler translates the source code into an **equally long and complex** sequence of machine code instructions. A separate execution phase then runs this machine code. **Advantages:** Very fast execution. **Disadvantages:** Slower development cycle (must recompile after every change).                                                    |
| **Just-in-Time (JIT) Compilation** | Used primarily by Virtual Machines (VMs). The byte code is first interpreted, but **frequently executed segments** of code (hotspots) are identified and compiled into **native machine code** for the host machine. The compiled segments are stored and reused, leading to performance that often approaches fully compiled code.                  |
| **Pre-processor**                  | A program that **processes a program immediately before it is compiled**. It is a macro-processing tool that commonly includes other files, defines symbolic constants, and conditionally compiles code sections. **Example:** The `#include` and `#define` directives in C/C++.                                                                     |