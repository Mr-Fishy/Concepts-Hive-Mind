# Backus Naur Form and Context-Free Grammars

## Context-Free Grammars

There are two of four generative devices or #grammars that define four classes of language.

Two of them, named #context-free and #regular. Are useful for describing the syntax of programming languages.

#tokens of programming languages can can be described by regular grammars. 
The #syntax can be described mostly, by context-free grammars.


## Origins of Backus-Naur Form

A new paper describing the language of ALGOL 58, was presented by John Backus, which was a new formal notation for specifying language syntax.

The notation would be modified later for ALGOL 60 by Peter Naur. And shortly after it would be called Backus-Naur Form  or #BNF for short.


BNF is considerably close to Chomsky's generative devices for #context-free languages, called context-free #grammars.

BNF and grammar are used interchangably.


## Fundamentals

A #metalanguage is a languages that is use to describe another language. BNF is a metalanguage for programming languages.

BNF uses abstractions for syntactic structures.

In a context free grammar there are two "sides" of a definition. known as #LHS(Left hand side) and #RHS(Right hand side).

The RHS and LHS of a definition consists of tokens, lexemes and maybe other definitions.

Together, these concepts make a #rule or #production. 

Taking Java for instance, a definition may take the appearance of:
```
<assign>-> <var> = <expression>
```

and it becomes obvious that the sentence above must be actually defined for this to be useful, here is an example:
```
<Assign>
|
<var>=<expression>
|
myvar = <expression>
|
myvar = 1
```

The abstractions in a grammar are called #non-terminals and the #lexemes  and #tokens are of rules are called #terminals. 

In short, a BNF description/grammar is a collection of rules.


Non-terminals can have distinct definitions, representing different accepted syntactic forms in the language.

Separate definitions can be separated by the | symbol.

Due to the nature of BNF, proper application can result in order of constructs, nested structures, operator precedence and associativity.

## Describing Lists

To describe a list in math, it is written with an ellipsis (...). BNF does not have this ellipsis, so recursion is used as an alternative.

A rule is considered #recursive if its LHS appears in its RHS. As so:
```
<list>->ident
|ident,<ident_list>
```

## Grammars and Derivations

A grammar is a generative device for defining languages.
The sentences of a language are generated through applications of the rules.
Beginning with a special nonterminal of the grammar called the #start_symbol. The sequence of rule applications is called a #derivation.

In a grammar the start symbol represents a complete program, and is often named `<program>`.

All derivation begin with the start symbol. => is read as "derives".

The next derived string is derived from the previous, by replacing one of the *non-terminals* withe the nonterminals definitions.

Each string in the derivation, including the start symbol is called a #sententialform.

Derivations that use the leftmost terminal replacement from the previous sentential form are called #leftmostderivations.

Derivation occurs until there are no nonterminals in the sentence. The sentential form consisting only of: terminals or lexemes, is the generated sentence.

A derivation can also be rightmost, or in no particular order.

By exaustively choosing all combinations of RHS rules to replace nonterminals in the derivations, the entire language can be generated, unless it is finite, in which case would take forever.

## Parse Trees
#parsetrees
One of the most attractive features of grammars is that they naturally describe the hierarchical syntactic structure of the sentences of the languages they define. These hierarchical structures are called **parse trees**

Every internal node of a parse tree is labelled with a nonterminal symbol.
Every leaf is labelled with a terminal symbol.
Every subtree of a parse tree describes on instance of an abstraction in the sentence.


## Ambiguity
#ambiguity 

A grammar that generates a sentential form for which there are two or more distinct parse trees is said to be **ambiguous**.

The ambiguity occurs because the grammar specifies slightly less syntactic structure than does the grammar before the previous one. 

Rather than allowing the parse tree of an expression to only grow on the right, this grammar allows growth on **both** left and right.

The Syntactic ambiguity of language structures is a problem because compilers often base the semantics of those structures on their syntactic form. Specifically, the compiler chooses the code to be generated for a statement by examining its parse tree. If a language structure has more than one parse tree, then the meaning ***cannot be determined uniquely***.

If they are ambiguous, they include the following: (1) if the grammar generates a sentence with more than one leftmost derivation **and** (2) if the grammar generates a sentence with more than one right most derivation

In many cases, an ambiguous grammar can be rewritten to be unambiguous but still generate the desired language.

## Operator Precedence
#grammar #operators  #non-terminals #derivation #parsetrees 
When an expression includes two different operators, such as : X+Y* Z, one semantic issue is order of evaluation by the two operators. In this example, add first or multiply first?

This semantic question can be answered by assigning different precedence levels to operators.

If * has a higher precedence than + (assigned by the language designer), multiplication will be done first, regardless of the order of appearance of the two operators in the expression.

A grammar can describe certain syntactic structures so that part of the meaning of the structure can be determined from its parse tree.

In the first parse tree we looked at, the multiplication operator is **lower in the tree** meaning that it has precedence over the addition operator in this case.

The ordering is specified by using **separate nonterminal symbols** to represent the operands of the operators that have different precedence.


The connection between parse trees and derivations is very close.

Either can be constructed from the other. Every derivation with an unambiguous grammar has a unique parse tree, although that tree can be represented by different derivations.

For example the following derivation of the sentence A = B + C * A is different ffrom the derivation of the same sentence given previously. This a rightmost derivation, where the previous ones are leftmost.

Both however, are represented by the *same* **parse tree**.



## Associativity of Operators
#grammar #leftrecursive #rightrecursive
When an expression includes two operators that have the *same* precedence, for example (* and / have the same here) A / B * C, a semantic rule is required to specify which would have precedence.

This rule is called **associativity**.

An expression with two occurrences of the same operator has the same issue, as per example (A/B/C).

As was the case with precedence, a grammar for expressions may correctly imply operator associativity.

In mathematics addition is associative, meaning left and right associative orders of evaluation mean **the same thing**. Floating point addition on a computer however is not necessarily associative.

When a grammar rules has its LHS also appearing at the beginning of its RHS, the rule is **left recursive**. This left recursion implies left associativity.

For example, the left recursion rules of the grammar we previously looked at, causes both addition and multiplication to be left associative.

Unfortunately, left recursion disallows some important syntax analysis algorithms. When one of them is to be used, the grammar **must** be modified to remove the left recursion.

In most languages that provide the exponentiation operator, its right associative. to indicate right associativity, right recursion can be used.



## An Unambiguous Grammar for `if-else`

The BNF rules for Java ` if-else` are as follows:
```
<if_stmt> -> if (<logic_expr>) <stmt>

if(<logic_expr>)<stmt> else <stmt>
```
If we add `<stmt> -> <if_stmt>`, this grammar is ambiguous, the simplest sentential form that illustrates this is:
`if(<logic_expr>) if (<logic_expr>)<stmt> else <stmt>`

Take the following clearer example:

```java
if(done == true)

if(denom == 0)
	quotient = 0;
	else quotient = num/denom;
```
if we construct a parse tree, we have two, and if we use the upper one provided[link], we would see that the else clause would be executed when `done` is not true, which probably is not what was intended by the author of the construct.

We will now develop an unambiguous grammar that describes this `if` statement. The rule `if` constructs in many language is that an else clause, when present, is match with the nearest previous unmatched then clause.

Therefore there cannot be an `if` statement without an `else` between a then clause and its matching `else`. So, for this situation, statements must be distinguished between those that are matched and those that are unmatched, where unmatched statements are `else` less `if`s and all other statements are matched.

The problem with the earlier grammar is that it treats all statements as if they had equal syntactic significance, that is if they were all matched.

To reflect this different category of statements, different abstractions, or nonterminals, must be used.

```
<stmt> -> <matched> | <unmatched>
<matched> -> if(<logic_expr) <matched> else <matched> | any non-if statement
<unmatched> -> if(<logic_expr>) <stmt> | if(<logic_expr>)<matched> else <unmatched>
```
Now there is only one possible parse tree using this grammar for the statement:
`if (<logic_expr>) if (<logic_expr>) <stmt> else <stmt>`

## Extended BNF
#BNF #EBNF #rule 
Most extended versions are called Extended BNF, or EBNF. They are not all exactly the same.

The extensions do *not* enhance the **descriptive power** of BNF, **only** its readability and writability

This extension allows lists to be built with a single rule, instead of recursion and two rules.
As an example:
`<ident_list> -> <identifier> {, <identifier>}`

This is a replacement of the recursion by a form of implied iteration, the part enclosed within braces can be **iterated any number of times**.

The third common extension deals with multiple-choice options. When a single element must be chosen from a group, the options are placed in parentheses and separated by the OR operator |.


## Grammars and Recognizers
#context-free #grammar #recognition 
Given a context-free grammar, a recognizer for the language generated by the grammar can be algorithmically constructed.

A number of software systems have been developed that perform this construction. These systems allow a quick creation of the syntax analysis part of a compiler for a new language and are therefore quite valuable.
One of the first syntax analyzer generators is named yacc (yet another compiler compiler). There are many which exist now.