# Attribute Grammars
#attribute #grammar #staticsemantics
An **attribute grammar** is a device used to describe more of the structure of a programming language than can be described with a context-free grammar.

An attribute grammar is an **extension** to a context-free grammar. This extension allows certain language rules to be conveniently described, such as type compatibility.

Before we formally define the form of attribute grammars, we must clarify the concept of **static semantics**.
#### 3.4.1 Static Semantics
#BNF #syntax #rule 
Some characteristics of programming languages are hard to describe with BNF, and some, impossible.

A difficult rule for example, is that Java does not allow floating points to be assigned to integers, but the opposite is legal.

If all the typing rules of Java were specified in BNF, the grammar would be **too large to be useful.**

A syntax rule that cannot be specified in BNF, consider that all variables must be declared **before they are referenced.** This has been proven to be impossible to specify in BNF.

These problems show the categories of language rules called: **static semantics rules.**

The **static semantics** of a language is indirectly related to the **meaning** of programs during execution. It instead has to do with the **legal forms** of programs (syntax rather than semantics.)

Many static semantic rules of a language state its **type constraints**. Static semantics, is named as such because the analysis required to check the types can be done at compile time.

Due to the problems describing static semantics with BNF, more powerful mechanism have been designed, such as: attribute grammars, which was designed to describe both syntax and static semantics of programs.

Attribute grammars are a formal approach to both describing **and** checking the correctness of the static semantics rules of a program.

Although they are not always used in a formal way, the basic concepts of attribute grammars are at least informally used.

Dynamic semantics, which is the meaning of expressions, statement and program units, is discussed later.

## Basic Concepts
#semantics #staticsemantics #attribute 
Attribute grammars are context-free grammars to which have been added attributes, attribute computation functions, and predicate functions.

**Attributes** are associated with grammar symbols (terminal and nonterminal symbols). Are similar to variables, since they can have **values assigned to them.**

**Attribute computation functions** also known as semantic functions are associated with grammar rules. They are used to specify how attribute values are computed.

**Predicate functions**, which state the static semantic rules of the language, are associated with grammar rules.

This will be clearer than these definitions when they get formally defined, and seen examples.

## Attribute Grammars Defined
#attribute #semantics #parsetrees 
An attribute grammar is a grammar with the following additional features:
- Associated with each grammar symbol X, is a set of attributes A(X).
	- The set A(X) consists of two disjoint sets S(X) and I(X), called synthesized and Inherited attributes respectively.
		- Synthesized attributes are used to pass **semantic information up** a parse tree
		- Inherited attributes pass **semantic information down and across** a parse tree

- Associated with **each** grammar rule is a set of semantic functions and *possibly* empty set of predicate functions over the attributes of the symbols in the grammar rule.
	- For a rule the X<sub>0</sub> -> X<sub>1</sub> ... X<sub>n</sub>, synthesized attributes of X<sub>0</sub> are computed with semantic functions of the form S(X<sub>0</sub>) = f(A(X<sub>1</sub>), ..., A(X<sub>n</sub>)). So the value of a synthesized attribute on a parse tree node depends only on the values of the attributes on that node's children nodes.
	- Inherited attributes of symbols X<sub>j</sub>, 1<=j<=n (in the rule above), are computed with a semantic function in the form I(X<sub>j</sub>) = f(A(X0 ), ..., A(X<sub>n</sub>)). 
		- So the value of an inherited attribute on a parse tree node depends on the attribute values of that node's parent node and those of its sibling nodes. Please do note that to avoid circularity, inherited attributes are often restricted to functions of the form I(X<sub>j</sub>) = f(A(X<sub>0</sub>,...,A(X( _ {j-1}))). This form **prevents** an inherited attribute from depending on itself or on attributes to the right in the parse tree.

- A predicate function has the form of a **Boolean expression** on the **union** of the attribute set {A(X<sub>0</sub>), ... , A(X<sub>n</sub>)} and a set of literal attribute values.
	- This means that the only derivations in the attribute grammar are those in which every predicate associated with every nonterminal is true.
	- A false predicate function value indicates a violation of the syntax or static semantics rules of the language.

A parse tree of an attribute grammar is the parse tree based on its underlying BNF grammar, with a possible empty set of attribute values attached to each node.
IF all of the attributes in the parse tree have been computed, the tree is said to be **fully attributed.** 
Although in practice it is not always done this way, it **can be convenient** to think of attribute values as being computed after the complete unattributed parse tree has been constructed by the compiler.

## Intrinsic Attributes
#intrinsic #synthetic 
**Intrinsic attributes** are synthesized attributes of leaf nodes, whose values are **determined outside the parse tree**.

For example, the type if an instance of a variable in a program could come form the symbol table, which is used to store variable names and their types.

The contents of the symbol table are set base on earlier declaration statements.
Initially assuming that an **unattributed** parse tree has been constructed and that **attribute values are needed**, the only attributes with values are **the intrinsic attributes of leaf nodes.** Given the intrinsic attribute values on a parse tree, the semantic functions can be used to compute the remaining attribute values.


## Examples of Attribute Grammars
#staticsemantics 
As a very simple example of how attribute grammars can be sued to describe static semantics, consider the following fragment of an attribute grammar that describes the rule that the name on the `end` of an Ada procedure must match the procedure's name.
(This rule cannot be stated in BNF)

The string attribute of `<proc_name>`, denoted by `<proc_name>`.string , is the actual string of characters that were found immediately following the reserved word `procedure` by the compiler. Notice that when there is more than one occurrence of a nonterminal in a syntax rule in an attribute grammar, the **nonterminals are subscripted** with brackets to distinguish them.
Neither the subscripts nor the brackets are part of the described language.
```EBNF
Syntax rule: <proc_def> -> procedure <proc_name>[1]
							<proc_body> end <proc_name>[2];
Predicate: <proc_name>[1] string == <proc_name>[2].string
```

In this example, the predicate rule states that the name string attribute of `<proc_name>` nonterminal in the subprogram header **must match the name string attribute of the <proc_name>** nonterminal following the end of the subprogram.

Let us consider a larger example of an attribute grammar.
In this case, we will illustrate how an attribute grammar can be used to **check the type rules** of a simple assignment statement.
The syntax and static semantics of this assignment are as follows:
```Syntax
<assign> -> <var> = <expr>
<expr> -> <var> +<var> | <var>
<var> -> A | B | C
```
Static semantics:
- The **only** variable names are A, B, and C.
- The right side of assignments can either be a variable **or** expression in the form of a variable added to another variable.
- The variables can be **one of two** types: int or real.
- When there are two variables on the right side fo an assignment, they need **not** be the same type.
- The type of the expression when the operand types are **not the same is always real**
	- When they are the same, the expression type **is that of the operands**
- The type of the **left side** of the assignment must match the type of the **right side**.
	- So the types of operands in the right side can be mixed, but the assignment is valid **only if the target and value resulting** from evaluating the right side **have the same type**.
- The attribute grammar specifies these static semantic rules.

The attributes for the non terminals in the example attribute grammar are described as follows:
- **actual type**: A **synthesized** attribute associated with the nonterminals `<var>` and `<expr>`. It is used to store the actual type, int or real of a variable or expression.
	- In the case of a variable, the actual type is intrinsic.
	- In the case of an expression, it is determined from the actual types of the child node or children nodes of the `<expr>` nonterminal.
- **expected type**: An **inherited** attribute associated with the nonterminal `<expr>`. It is used to store the type, int or real, that is **expected form the expression**, as determined by the type of the variable on the  **left side** of the assignment statement.

## Computing Attribute Values
#parsetrees #grammar #attribute 
Now, the process of computing a parse tree, sometimes called **decorating** a parse tree. If all attributes were inherited, this could proceed in a completely top-down order, from the leaves to the root, if all the attributes were synthesized.

Because our grammar has both synthesized and inherited attributes, the evaluation process **cannot be in any single direction**. The following is an evaluation of the attributes,in an order in which it is possible to compute them:

```
1. <var>.actual_type <- look-up(A) (Rule 4)
2. <expr>.expected_type <- <var>.actual_type (Rule 1)
3. <var>[2].actual_type <- look-up(A) (Rule 4)
   <var>[3].actual_type <- look-up(B) (Rule 4)
4. <expr>.actual_type <- either int or real (Rule 2)
5. <expr>.expected_type == <expr>.actual_type is either TRUE or FALSE (Rule 2)
```

## Evaluation
#staticsemantics #compiler #compilers #attribute #grammars #syntax #staticsemantics #parsetrees 

Checking the static semantic rules of a language is an **essential** part of all compilers. Even if a compiler has never heard of an attribute grammar, he or she would need to use the **fundamental ideas of attribute grammars** to design the checks of static semantics rules on his or her compiler.

The main difficulties with using an attribute grammar to describe all syntax and static semantics of a real contemporary programming language is the size and complexity of said attribute grammar.

The large number of rules makes it difficult to read and write.
Large parse trees are costly to evaluate, too.

less formal attribute grammars are commonly used for compiler writers, who are more interested in the process of producing a compiler than formalism.