#  Describing the Meaning of Programs: Dynamic semantics
#notation #dynamicsemantics 
Describing dynamic semantics, or meaning, of the expressions, statements, and program units of a programming language. Because of power and naturalness of available notation, describing syntax is a relatively simple matter.

On the other hand, no **universally accepted notation** or **approach** has been devised for dynamic semantics.

In this section, we briefly describe multiple methods that have been developed, in this section semantics means *dynamic semantics*.

There are several different reasons underlying the need for methodology and notation for describing semantics.

For programmers, they must know what the precise statements of the language do before they can use them effectively in their programs.

Compiler writers have to know what language constructs *mean* to design implementations for them correctly. 

If there were a precise semantics specification of a programming language, programs  written in the language potentially could be proven correct without testing. Also compilers could be shown to produce programs that exhibited exactly the behavior given in the language definition. That is to say their correctness could be verified.

A complete specification of the syntax and semantics of a programming language could be used by a tool to generate a compiler for a language automatically.

Finally, language designers, who would develope the semantic descriptions of their languages, could in the process discover ambiguities and inconsistencies in their designs.

Software devs and compiler designers would typically determine semantics of programming languages by reading English explanations. Because of the imprecision and incompleteness of this approach this is clearly unsatisfactory. Due to the lack of complete semantics specifications of programming languages, programs are rarely proven correct without testing, and commercial compilers are never generated automatically from language descriptions.

Scheme, is one of a few programming languages whose definition includes a formal semantics description. This method is not described here, but rather approaches towards imperative languages.

## Operational Semantics
#operationalsemantics #dynamicsemantics #interpreters #compiler 
**Operational Semantics** is describing the meaning of a statement or program by specifying the effects of running it on a machine.

The effects on the machine are viewed as the sequence of changes in its state, where the machine's state is the collection of the values in its storage.
An obvious operational semantics description, then, is given by executing a compiled version of the program on a computer.

There are several problems  with this approach for complete formal semantics descriptions.

First the individual steps in the execution of machine language and the resulting changes to the state of the machine are too small and numerous. Second the storage of a real computer is too large and complex.

There are usually several levels of memory devices, as well as connections to enumerable other computers and memory devices through networks.

Therefore, machine languages and real computers are not used for formal operational semantics.

Rather intermediate-level languages and interpreters for idealized computers are designed specifically for the process.

There are different levels of uses of operational semantics. At the highest level, the interest is in the final result of the execution of a complete program. This is sometimes called **natural operational semantics**. At the lowest level, operational semantics can be used to determine the precise meaning of a program through an examination of the complete sequence of state changes that occur when the program is executed.

This use is sometimes called **structural operational semantics**.

##  The Basic Process
#unambiguous #dynamicsemantics #semantics 
The first step in creating an operational semantics description of a language is to design an appropriate intermediate language, where the primary desired characteristic of  the language is clarity. Every construct of the intermediate language must be **obvious and have unambiguous meaning.** 

This language is at the intermediate level, because machine language is too low-level to be easily understood, and another high-level language is obviously not suitable. 

If the semantics description is to be used for natural operational semantics, a virtual machine (an interpreter), must be constructed for the intermediate language.

The virtual machine can be used to execute: single statements, code segments, or whole programs.

The semantics description can be used without a virtual machine if the meaning of a single statement is all that is required. In this use, which is structural operational semantics, the intermediate code can be visually inspected.

The basic process of operational semantics is not unusual. In fact, the concept is **frequently** used in programming textbooks and programming language reference manuals.

The semantics for the `C for` construct can be described in terms of simpler statements as in:
```
C Statement
for(expr1;expr2;expr3){
...
}

Meaning:
	expr1l
loop: if expr2 == 0 goto out
	...
	expr3;
	goto loop;
out:
	...
```

The human reader is in this case the virtual computer, and is assumed to be able to "execute" the instructions in the definition correctly, and recognize the effects of the "execution".

The intermediate language used for formal operational semantics descriptions is often highly abstract.
The language is meant to be convenient for the *virtual machine*, rather than for human readers.
For our purposes, a more human-oriented intermediate language could be used.
Consider the following example statements, which should be adequate for describing semantics of the simple control statements of a typical programming language:

```
ident = var
ident = ident + 1
ident = ident - 1
goto label
if var relop var goto label
```

In these statements, relop is one of the relational operators from the set {=, <>, >, <, <=, <=}, ident is an identifier, and var is either an identifier or a constant.

A slight generalization of these statements allows a more general arithmetic expressions and assignment statements to be described. The new statements are 

ident = var bin_op var
ident = un_op var

where bin_op is a binary arithmetic operator and un_op is a unary operator. Multiple arithmetic data types and automatic type conversions, of course, complicate this generalization.
Adding a few more **relatively simple** instructions would allow the semantics of arrays, records, pointers and subprograms to be described.


##  Evaluation
#operationalsemantics  #dynamicsemantics 
The first and **most significant use** of the formal operational semantics was to describe the semantics of PL/I.
That particular abstract machine and the translation rules for PL/I were together named the Vienna Definition Language (VDL), where it was designed.

Operational semantics provides an **effective means** of describing semantics for language users and language implementors, as long as the descriptions are **kept simple and informal.** 
The VDL of PL/I is so complex, it serves no practical purpose

Operational semantics depends on programming languages of lower levels, not mathematics.

The statements of one programming languages are described in terms of the statements of a lower-level programming language. This approach can lead to circularities, in which concepts are indirectly defined in terms of themselves. The methods described in the following two sections are much more formal, in the sense that they are based on mathematics and logic, **not** programming languages.


#  Denotional Semantics
#DenotationalSemantics #dynamicsemantics 
**Denotational semantics**: rigorous and most widely known formal method for describing the meaning of programs. It is based on recursive function theory.

The text below will provide a introduction to the central concepts, and a few examples that are relevant to programming languges.

## The process:

Constructing a denotational semantics specification for a programming languages requires one to define for each language entity both a mathematical object **and** a function that maps instances of the language entity onto instances of the mathematical object.

Because objects are rigorously defined, they model the exact meaning of their corresponding entities.

This idea is based on the fact that there are rigorous ways of manipulating mathematical objects, but not programming language constructs.

The difficulty in Denotational semantics is the mapping between functions and objects.

It is called denotational because **mathematical objects denote the meaning of their corresponding syntactic entities.**

The mapping functions of a denotational semantics programming language specification like all functions, have a domain and a range.
The domain is the collection of values **that are legitimate parameters to the function**. The range **is the collection of objects to which the parameters are mapped**. In denotational semantics, the domain is called **syntactic domain**, because it is syntactic structures that are mapped. The range is called **semantic domain**.

Denotational semantics is **related** to operational semantics.
In **operational semantics**, **programming language constructs are translated into simpler programming language constructs**, which become the **basis of the meaning of the construct**.
In denotational semantics, programming language constructs are mapped to mathematical objects, **either sets or more often, functions**. However, **unlike** operational semantics, denotational semantics does not model the step-by-step computational processing of programs.

## Two Simple Examples

We use a very simple language construct, character sting representations of binary numbers, to introduce the denotational method. The syntax of such binary number can be described by the following grammar rules:
```Java
<bin_num> -> '0'
| '1'
| <bin_num> '0'
| <bin_num> '1'
```
A parse tree for the example of the binary number `110` is shown below.
Notice that we put apostrophes around the syntactic digits to show they are not mathematical digits.
This is similar to the relationship between **ASCII** coded digits and mathematical digits. When a program reads a number as a string, it must be converted to a mathematical number before it can be used as a value in the program.

```Java
		<bin_num>
		/      \
	<bin_num>  '0'
	/        \
<bin_num>    '1'
	|
   '1'
```
For the image above:
The syntactic domain of the mapping function for binary numbers is the set of all character string representation of binary numbers. The semantic domain is the set of nonnegative decimal numbers, synbolized by N.

To describe the meaning ofbinary numbers using **denotational semantics**, we associate the actual meaning (a decimal number) with each rule that has a **single terminal symbol** as its RHS.

The semantic function, named M<sub>bin</sub>, maps the syntactic objects, as described in the previous grammar rules, to the objects in N, the set of non-negative decimal numbers. The function M<sub>bin</sub> is defined as follows:

M<sub>bin</sub> ('0')=0
M<sub>bin</sub> ('1')=1
M<sub>bin</sub> (<bin_num> '0') = 2 * M<sub>bin</sub> (<bin_num>)
M<sub>bin</sub> (<bin_num> '1')= 2 * M<sub>bin</sub> (<bin_num>) +1

The meanings, or denoted objects (in this case decimal numbers), can be attached to the nodes of the parse tree shown on the previous page, yielding the tree below. 
This is syntax-directed semantics. Syntactic entities are mapped to mathematical objects with concrete meaning.

```Java
		<bin_num>
		/       \
	<bin_num>   '0'
	/      \
<bin_num>  '1'
 |
'1'
```

Now, another example, where it is describing the meaning of syntactic decimal literals, the semantic domain is once again the **set N**.

```Java
<dec_num> -> 0|1|2|3|4|5|6|7|8|9
	| <dec_num> -> (0|1|2|3|4|5|6|7|8|9)
```

The denotational mappings for these syntax rules are:

M<sub>dec</sub> ('0') = 0, M<sub>dec</sub> ('1') = 1, M<sub>dec</sub> ('2') = 2, ... , M<sub>dec</sub> ('9') = 9
M<sub>dec</sub> (<dec_num> '0') = 10 * M<sub>dec</sub> (<dec_num>)
M<sub>dec</sub> (<dec_num> '1') = 10 * M<sub>dec</sub> (<dec_num>)+1
Mdec (<dec_num> '9') = 10 * M<sub>dec</sub> (<dec_num>)+9


In the following sections, we present the denotational semantics descriptions of a few simple constructs. The most important simplifying assumption made here is that both the syntax and static semantics of the constructs are correct. 
In addition, we assume that only two scalar types are included: Integer and Boolean.

##  The State of a Program
#variable #DenotationalSemantics #dynamicsemantics 
The denotational semantics of a program could be defined in terms of state changes in an ideal computer.
Operational semantics are defined in this way, and denotational semantics are defined in nearly the same way.

In a further simplication, denotational semantics is **defined in terms of only the values of all the program's variables**. So, denotational semantics uses **the state of the program to describe meaning** ,whereas **operational semantics uses the state of a machine.**.

The key difference between operational and denotational semantics is that state changes in operational semantics are defined by coded algorithms, written in some programming language, whereas denotational semantics, state changes are defined by mathematical functions.

Let the state of *s* of a program be represented as a set of ordered pairs, as follows:

s= {<i<sub>1</sub>,v<sub>1</sub>>,<i<sub>2</sub>,v<sub>2</sub>>,..., <i<sub>n</sub>,v<sub>n</sub>>}

Each i is the name of a variable, and the associated v's are the current values of those variables.
Any of the v's can have a special value **undef**, which indicates that its associated varaible is currently undefined. Let VARMAP be a function of two parameters: a variable name and the program state.
The value of VARMAP (i<sub>j</sub>, s) is v<sub>j</sub> (the value paired with i<sub>j</sub> in state *s*).
Most semantic mapping functions for **programs and program constructs** map state to states. These state changes are used to define the meanings off programs and program constructs. Some language constructs, for example, expressions are mapped to values, not states.

## Expressions
#dynamicsemantics #DenotationalSemantics 
Expressions are fundamental to most programming languages.
We assume here that expressions have no side effects.
Furthermore, we deal with **very simple expressions**, the only operators are + and * , and an expression can have at most one operator, the only operands are scalar integer variables and integer literals; there are no parenthesiss; and the value of an expression is an integer.

Following is the BNF description of these expressions:
```
<expr> -> <dec_num> | <var> | <binary_expr>
<binary_expr> -> <left_expr> <operator> <right_expr>
<left_expr> -> <dec_num> | <var>
<right_expr> -> <dec_num> | <var>
<operator> -> + | *
```
The only error we consider in expressions is a variable having an undefined value.
Let Z be the set of integers, and let `error` be the error value. Then Zu{error} is the semantic domain for the denotational specification for our expressions.

The mapping function for a given expression `E` and state `s` follows. To distinguish between mathematical function definitions and the assignment statements of programming languages, we use the the `<delta>` symbol to define mathematical functions.
The implication symbol, =>, used in this definition connects the form of an operation with its associated case (or switch) construct.

Dot notation is used to refer to the child notes of a node. For example, `<binary_expr>.<left_expr>` refers to the left child node of `<binary_expr>`.

```
Me(<expr>,s) delta = case <expr> of
	<dec_num> => Mdec(<dec_num>,s)
	<var> if VARMAP (<var>,s) == undef
			then *error*
			else VARMAP (<var>,s)
	<binary_expr> =>
	if(Me (<binary_expr>.<operator> == undef) OR
	Me (<binary_expr>.<right_expr>,s) == undef)
	then *error*
	else if (<binary_expr>.<operator> == '+')
		then Me (<binary_expr>.<left_expr>, s) +
			  Me (<binary_expr>.<right_expr>,s)
		else Me (<binary_expr.<left_expr>,s) *
			  Me (<binary_expr>.<right_expr>,s)
```

## Assignment Statements
#DenotationalSemantics #dynamicsemantics 
An assignment statement is an expression evaluation plus the setting of the target variable to the expression's value. In this case, the meaning function maps a state to a state. this can be described with the following

```js
Ma (x = E, s) Δ = if Me (E, s) == error 
  then error 
  else s′ = {⟨i₁, v₁′⟩, ⟨i₂, v₂′⟩, …, ⟨iₙ, vₙ′⟩},where 
  comparisionfor j = 1, 2, …, n  
    if i_j == x  
    then v_j′ = Me (E, s)  
    else v_j′ = VARMAP (i_j, s)
```

Note that the comparison in the third last line above, i<sub>j</sub> = = x, **is of names, not values.**


## Logical Pretest Loops
#DenotationalSemantics #dynamicsemantics  
The denotational semantics of a **logical pretest loop** is deceptively simple.
To speed up the discussion, assume that there are two other existing mapping functions, Msl and Mb, that map statement lists and states to states and Boolean expressions to Boolean values (or error), respectively. the function is:
```js
M1(while B do L, s) Δ =  if Mb(B, s) == undef 
	then error  
    else if Mb(B, s) == false 
	    then s  
	    else if Msl(L, s) == error 
		    then error  
		    else Ml(while B do L, Msl(L, s))
```

The meaning of the loop is **simply the value of the program variables after the statements in the loop have been executed the prescribed number of times, assuming there have been *no errors*.**
In essence, the loop has been converted from iteration to recursion, where the recursion control is mathematically defined by other recursive state mapping funcitons.
Recursion is **easier to describe with math than iteration**
One observation is that this definition, much like actual program loops, may compute nothing because of nontermination.

## Evaluation

Objects and functions, such as those used in earlier constructs, can be defined for the other syntactic entities of programming languages.

When a **complete system** has been defined for a given language, it can be used to determine the meaning of complete programs in that language. This provides a **framework** for thinking about programming in a highly rigorous way.

As before, denotational semnatics can be used as an aid to language design. For statements which denotational semantic description **is too complex and difficult** may indicate that a different design may be in order.

Because of the complexity of denotational descriptions, they are little use to language users. However they are extremely verbose and are an excellent way to describe a language concisely.


#  Axiomatic Semantics
#axiomatic #semantics #dynamicsemantics
**Axiomatic semantics**, named as such because it is based on mathematical logic, is the most abstract approach to semantics specification.
Rather than directly specifying the meaning, axiomatic semantics specifies **what can be proveen about the program**. Recall that one possible use of semantic specifications is **to prove correctness of programs**.

In axiomatic semantics, there is no model of the state of a machine or program or model of state changes that take place as the program is executed.

The meaning for a program is based on relationships among program **variables and constants**, which are the same for every execution of the program.

Axiomatic semantics has two distinct applications: program verification and program semantics specification. 
This section focuses on **program verification**.

Axiomatic semantics was defined in conjunction with the development of an approach to proving the correctness of programs.
Such correctness proofs, when they can be constructed *show* that a program performs the computation described by its specification.

In a proof, each statement of a program is **both** preceded and followed by a logical expression that specifies constraints on program variables. 
These, rather than the entire state of an abstract machine, are used to specify the meaning of the statement. The notation used to describe constraints, the language of axiomatic semantics, is **predicate calculus**. Although simple Boolean expressions are often adequate to express constraints, in some cases they are not.

When axiomatic semantics is used to specify formally the meaning of a statement, **the meaning is defined by the statement's effect on assertions about the data affected by the statement**.

## Assertions
#predicates #assertions
The logical expressions used in axiomatic semantics are called **predicates** or **assertions**.
An assertion immediately *Preceding a program statement*, describes the constraints on the program variables at that point in the program.
An asssertiaon immediately *following a statement* describes the *new constraints* on those variables (and possibly others) after execution of the statement. These assertions are called **precondition** and **postcondition** respectively, of the statement.
For two adjacent statement, the postconditoin or proof of a given program requires that every statement in the program has aboth a precondition and postcondition.

In the following sections, we examine assertions from the point of view that preconditions for statements are computed from given postconditions.
Although it is possible to consider these **in the opposite sense**. 
We assume all variables are integer type. As an example, consider the folloing assignment statement and postconditoin:
`sum = 2 * x + 1 {sum > 1}`

Precondition and Postcondition assertions are *presented in braces* to distinguish them from parts of *program statements*. One possible precondition for this statement is `{x>10}`

In axiomatic semantics, the **meaning** of a specific statement is defined by its precondition **and** its post condition. In effect, the two assertions specify precisely the effect of executing the statement.

In the following subsections, we focus on correctness proofs of statements and programs, which is a common use of axiomatic semantics. 

*The more general concept of axiomatic semantics is to state precisely the meaning of statements and programs in terms of logic expressions.* Program verification is **one** application of axiomatic descriptions of languages. 


### Weakest Preconditions
#preconditions #postconditions #inferencerule #consequent #antecedent
The **weakest precondition** is the least restrictive precondition that will guarantee the validity of the associated post condition.

As per example in the previous section x being greater than 10, 50 and 1000 are all valid preconditions. The weakest in this case being `{x>0}`.

If the weakest precondition can be computed from the most general post-condition for each of the statement types of a language, then the processes used to compute these preconditions provide a concise description of the semantics of that language.
Furthermore, correctness proofs can be constructed for programs in that language.

A program proof is begun by using the **characteristics of the results of the program's execution as the postcondition of the last statement of the program.**
This post condition, along with the last statement, is used to compute the weakest precondition for the last statement.
This process continues until the beginning of the program is reached. At that point, the precondition of the first statement states the conditions under which the program will compute the desired results.
IF these conditions are implied by the input specification of the program, the program has been verified to be correct.

An **inference rule** is a method of inferring truth from one assertion on the basis of the values of other assertions. The general form of an inference rule is as follows:
Sn/S
Where S<sub>n</sub> = S1, S2... -> Sn
This rule states that if S1, S2,... and Sn are true, then the truth of S can be inferred.
The top part of an inference rule is called **its antecedent** the bottom part is called the **consequent**.

An **axiom** is a logical statement that is assumed to be true. Therefore, an axiom is an inference rule **without** an antecedent.

For some program statements, the computation of a weakest precondition is simple and can be specified by an axiom.  In most cases, however, the weakest precondition can be specified only by an inference rule.

To use axiomatic semantics with a given programming language, whether for correctness proofs or for formal semantics specifications, either an axiom or inference rule **must exist** for **each kind of statement** in the language.
Note that in the next sections, assume that neither arithmetic nor boolean expressions have *side effects*.

## Assignment statements.
#preconditions #postconditions #statementaxiom
The precondition and post condition of an assignment statement together define its meaning.
To define the meaning of an assignment statement **there must be a way to compute the repcondition from its postcondition.**

Let x = E be a general assignment statement and Q be its postcondition. Then, its weakest precondition, P, is defined by the axiom
`P=QxSE`
which means that P is computed as Q with all instances of x replaced by E. For example, if we have the assignment statement and postcondition
```
a=b/2-1 {a<10}
```
the weakest precondition is computed by substituting `b/2-1` for `a` in the postcondition {a<10}, as followsL
```
b/2-1 <10
b<22
```

Thus the weakest precondition  for the given assignment statement and postcondition is {b<22}. Remember that teh **statement axiom** is guaranteed to be correct only in the absence of side effects. An assignment statement has a side effect if it changes some variable other than its target.

